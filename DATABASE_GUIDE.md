# Paper Control - Database Architecture Guide

**Version:** 1.0
**Last Updated:** 2026-01-12
**Database Type:** Firebase Firestore (NoSQL Cloud Database)

---

## Table of Contents
1. [Database Overview](#database-overview)
2. [Collections Structure](#collections-structure)
3. [Data Relationships](#data-relationships)
4. [Primary Keys & Foreign Keys](#primary-keys--foreign-keys)
5. [API Endpoints](#api-endpoints)
6. [Data Flow Patterns](#data-flow-patterns)
7. [Query Patterns](#query-patterns)
8. [Key Business Logic](#key-business-logic)

---

## Database Overview

### Technology Stack
- **Database:** Firebase Firestore
- **Project ID:** paper-control-6bce2
- **Authentication:** Firebase Auth (Email/Password)
- **Image Storage:** ImageKit CDN
- **Notifications:** Telegram Bot API
- **Configuration:** `/src/services/firebase.js`

### Database Philosophy
- NoSQL document-based structure
- Denormalized data for read performance
- Subcollections for one-to-many relationships
- Dual storage pattern for invoices (client-specific + centralized)

---

## Collections Structure

### 1. **users** Collection
**Purpose:** Store user accounts with authentication and role-based access control

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  uID: string,              // Firebase Auth UID (Primary Key)
  name: string,             // User's full name
  email: string,            // User's email address
  role: string,             // "admin" | "worker" (determines permissions)
  chatId: string,           // Telegram chat ID for notifications (optional)
  createdAt: timestamp      // Account creation timestamp (optional)
}
```

**Key Fields:**
- `uID`: Links to Firebase Authentication user
- `role`:
  - **"admin"**: Full access (analytics, user management, all features)
  - **"worker"**: Limited access (hides sensitive data like totalKg, orgName)
- `chatId`: Required for receiving Telegram notifications about low paper

**Access Patterns:**
```javascript
// Query user by Firebase Auth UID
const q = query(collection(db, 'users'), where('uID', '==', firebaseUser.uid));

// Get all admin users (for notifications)
const q = query(collection(db, 'users'), where('role', '==', 'admin'));
```

---

### 2. **clients** Collection
**Purpose:** Core collection storing restaurant/business client information

**Document ID:** Auto-generated by Firestore

**Schema (Unique Design):**
```javascript
{
  id: string,                    // Document ID (auto-generated)
  name: string,                  // Client's business name
  restaurant: string,            // Restaurant display name (if different from name)
  orgName: string,               // Organization legal name (for invoices)
  displayName: string,           // Preferred display name
  addressShort: string,          // Human-readable address
  addressLong: GeoPoint,         // Firebase GeoPoint { latitude, longitude }
  geoPoint: string,              // Coordinates as string (deprecated)
  designType: "unique",          // Design type flag
  shellNum: string,              // Shell/packaging number (optional)
  productID_2: string,           // FK -> products collection
  packageID: string,             // FK -> packageTypes collection
  gramm: string,                 // Weight in grams (stored as string)
  totalKg: number,               // All-time cumulative paper received (never decreases)
  paperRemaining: number,        // Current paper stock in kg (live inventory)
  totalRolls: number,            // Number of active paper rolls
  notifyWhen: number,            // Alert threshold in kg (triggers Telegram alert)
  comment: string,               // Internal notes/comments
  imageURL: string,              // Client photo/logo URL (ImageKit)
  branches: array,               // Array reference (subcollection exists)
  createdAt: timestamp           // Client creation date
}
```

**Schema (Standard Design):**
```javascript
{
  id: string,
  name: string,
  designType: "standart",        // Standard design flag
  productTypeID: string,         // FK -> productTypes collection
  catalogueItemID: string,       // FK -> catalogue collection
  gramm: number,                 // Weight in grams (stored as number)
  productName: string,           // Cached from catalogue (denormalized)
  packageType: string,           // Cached from catalogue (denormalized)
  totalKg: number,
  paperRemaining: number,
  totalRolls: number,
  notifyWhen: number,
  comment: string,
  imageURL: string,
  // ... other common fields
}
```

**Design Types Explained:**
1. **"unique"** (Уникальный): Custom-designed packaging, each client has independent paper inventory
2. **"standart"** (Стандартный): Standard label design, uses shared productTypes paper pool

**Key Metrics:**
- `totalKg`: Cumulative metric, only increases when paper is added
- `paperRemaining`: Live inventory, increases/decreases with paper in/out
- `totalRolls`: Calculated from paperRolls subcollection count
- `notifyWhen`: When `paperRemaining <= notifyWhen`, Telegram alert sent to admins

**Subcollections:**
- `paperRolls/{id}` - Individual paper rolls tracking
- `logs/{id}` - Activity history (paperIn/paperOut actions)
- `invoices/{id}` - Client-specific invoice records
- `branches/{id}` - Multiple branch locations (optional)

**Foreign Keys:**
- Unique design: `productID_2` → products, `packageID` → packageTypes
- Standard design: `productTypeID` → productTypes, `catalogueItemID` → catalogue

---

### 3. **clients/{clientId}/paperRolls** Subcollection
**Purpose:** Track individual paper rolls for each client (unique design only)

**Parent:** clients collection

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,                // Document ID
  dateCreated: timestamp,    // Roll creation/addition date
  paperRemaining: number     // Current paper remaining in this roll (kg)
}
```

**Business Logic:**
- Each document represents one physical paper roll
- `client.paperRemaining` = SUM of all `paperRolls.paperRemaining`
- `client.totalRolls` = COUNT of paperRolls documents
- When paper is used, individual rolls are decremented
- Allows tracking which specific rolls have paper remaining

**Example:**
```javascript
// Client has 3 rolls:
paperRolls/roll1: { paperRemaining: 50 }
paperRolls/roll2: { paperRemaining: 30 }
paperRolls/roll3: { paperRemaining: 0 }  // Depleted roll

// Client document shows:
totalRolls: 3
paperRemaining: 80  // 50 + 30 + 0
```

---

### 4. **clients/{clientId}/logs** Subcollection
**Purpose:** Track all paper movement history for each client

**Parent:** clients collection

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,               // Document ID
  date: timestamp,          // Action timestamp
  userID: string,           // FK -> users collection (who performed action)
  userName: string,         // Cached user name (denormalized)
  actionType: string,       // "paperIn" | "paperOut" | "correction"
  amount: number,           // Paper amount added/removed (kg)
  details: string           // Description/notes about the action
}
```

**Action Types:**
1. **"paperIn"**: Paper delivered to client (Priyemka process)
2. **"paperOut"**: Paper consumed/used by client
3. **"correction"**: Manual adjustment/correction

**Key Business Rules:**
- Only `actionType === "paperOut"` logs are counted for usage analytics
- Logs are used to generate daily/weekly/monthly consumption charts
- Each log tracks which user made the change for audit trail

**Query Examples:**
```javascript
// Get last 30 days of activity
const logsRef = collection(db, `clients/${clientId}/logs`);
const q = query(logsRef,
  where('date', '>=', thirtyDaysAgo),
  orderBy('date', 'desc')
);

// Get all paper consumption (for usage charts)
const q = query(logsRef, where('actionType', '==', 'paperOut'));
```

---

### 5. **clients/{clientId}/invoices** Subcollection
**Purpose:** Store client-specific invoice records

**Parent:** clients collection

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,                      // Document ID
  dateCreated: timestamp,          // Invoice creation date
  invoiceNumber: string,           // Generated invoice number
  userID: string,                  // FK -> users (who created invoice)
  userName: string,                // Cached user name
  orgName: string,                 // Organization name for invoice
  customRestaurantName: string,    // Override restaurant name (optional)
  senderCompany: string,           // Company issuing invoice (e.g., "White Ray")
  paymentType: string,             // "cash" | "transfer"
  totalInvoiceAmount: number,      // Total invoice sum
  products: array[{                // Array of invoice line items
    productID_2: string,           // FK -> products
    packageID: string,             // FK -> packageTypes
    gramm: number,                 // Product weight
    quantity: number,              // Quantity ordered
    price: number,                 // Unit price
    totalPrice: number             // quantity * price
  }]
}
```

**Dual Storage Pattern:**
- Saved to `clients/{clientId}/invoices` - Client-specific history
- **ALSO** saved to `all-invoices` root collection - Centralized analytics

**Payment Types:**
- **"cash"**: Cash payment
- **"transfer"**: Bank transfer

---

### 6. **clients/{clientId}/branches** Subcollection
**Purpose:** Store multiple branch/location information for clients with multiple sites

**Parent:** clients collection

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,                  // Document ID
  branchName: string,          // Branch name/identifier
  addressShort: string,        // Branch address
  addressLong: GeoPoint,       // Branch coordinates
  // ... other branch-specific fields
}
```

**Use Case:**
- Used when a client has multiple restaurant locations
- Can select branch when creating invoices
- Allows location-specific tracking

---

### 7. **products** Collection
**Purpose:** Base product definitions (ingredients like Sugar, Salt, etc.)

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,              // Document ID (Primary Key)
  productName: string,     // Product display name (e.g., "Sugar 5g", "Salt 2g")
  productCode: string,     // Product SKU/code (optional)
  // ... other product properties
}
```

**Referenced By:**
- clients collection (unique design)
- invoices (in products array)
- productTypes collection
- catalogue collection

**Usage:**
- Displayed in product selection dropdowns
- Base for creating productTypes combinations
- Used in invoice line items

---

### 8. **packageTypes** Collection
**Purpose:** Define packaging types (Stick, Sachet, etc.)

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,              // Document ID (Primary Key)
  type: string,            // Package type name (e.g., "Стик", "Саше")
  // ... other properties
}
```

**Hard-coded IDs in Analytics:**
```javascript
// These IDs are used in analytics calculations
"sKHbhJ8Ik7QpVUCEgbpP" = Stick (Стик)
"fhLBOV7ai4N7MZDPkSCL" = Sachet (Саше)
```

**Subcollections:**
- `possibleProducts/{id}` - Defines which products can use this package type

**Referenced By:**
- clients collection
- invoices products array
- productTypes collection

---

### 9. **packageTypes/{packageId}/possibleProducts** Subcollection
**Purpose:** Define product-package compatibility

**Parent:** packageTypes collection

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,              // Document ID
  productID: string,       // FK -> products
  // ... compatibility rules
}
```

**Business Logic:**
- Defines which products can be packaged in which package types
- Used to filter product selection dropdowns based on selected package

---

### 10. **productTypes** Collection
**Purpose:** Standard label design definitions (combinations of product + package + gramm)

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,                   // Document ID (Primary Key)
  packageID: string,            // FK -> packageTypes
  productID_2: string,          // FK -> products
  gramm: number,                // Weight in grams
  name: string,                 // Standard design name (optional)
  catalogueItemID: string,      // FK -> catalogue (optional)
  // ... other properties
}
```

**Purpose:**
- Represents a specific product+package+weight combination
- Used for "Standard Design" clients (designType: "standart")
- Multiple clients can share the same productType
- Shared paper pool across clients using same productType

**Subcollections:**
- `logs/{id}` - Usage logs for standard design paper

**Foreign Keys:**
- `packageID` → packageTypes
- `productID_2` → products
- `catalogueItemID` → catalogue (optional)

**Example:**
```javascript
productType1: {
  productID_2: "sugar-5g",
  packageID: "stick",
  gramm: 5,
  name: "Sugar 5g Stick Standard"
}
// Multiple clients can reference this productType
```

---

### 11. **productTypes/{productTypeId}/logs** Subcollection
**Purpose:** Track usage logs for standard design paper

**Parent:** productTypes collection

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,               // Document ID
  date: timestamp,          // Action timestamp
  userID: string,           // FK -> users
  userName: string,         // Cached user name
  actionType: string,       // "paperIn" | "paperOut" | "correction"
  amount: number,           // Paper amount (kg)
  clientId: string,         // FK -> clients (which client used this paper)
  details: string           // Description
}
```

**Difference from Client Logs:**
- Standard design logs are stored under productTypes, not clients
- Tracks usage across all clients using this productType
- Allows analytics on standard design consumption

---

### 12. **catalogue** Collection
**Purpose:** Store product catalog items with images and metadata

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,                  // Document ID (Primary Key)
  productName: string,         // Catalog product display name
  productCode: string,         // Catalog product code/SKU
  packageType: string,         // "стик" | "саше" (lowercase)
  usedMaterial: string,        // Material type (for filtering)
  description: string,         // Product description
  imageUrl: string,            // ImageKit CDN URL
  imagekitFileId: string,      // ImageKit file ID
  createdAt: timestamp,        // Created date
  updatedAt: timestamp         // Last updated date
}
```

**Key Fields:**
- `packageType`: Used for filtering by package type
  - "стик" (stick)
  - "саше" (sachet)
- `usedMaterial`: Material type filter
  - Example values: "Paper", "Plastic", "Biodegradable"
- `imageUrl`: ImageKit CDN URL for product image
- `imagekitFileId`: Required for ImageKit API operations

**Usage:**
- Display catalog in UI with filtering
- Select catalog item when creating standard design clients
- Link catalog to productTypes via `catalogueItemID`

**Referenced By:**
- productTypes collection (`catalogueItemID`)
- clients collection (standard design, `catalogueItemID`)

---

### 13. **all-invoices** Collection
**Purpose:** Centralized invoice storage for analytics (duplicate of client invoices)

**Document ID:** Auto-generated by Firestore

**Schema:**
```javascript
{
  id: string,                      // Document ID
  dateCreated: timestamp,          // Invoice creation date
  invoiceNumber: string,           // Invoice number
  userID: string,                  // FK -> users
  userName: string,                // Cached user name
  clientId: string,                // FK -> clients (which client)
  orgName: string,                 // Organization name
  customRestaurantName: string,    // Override restaurant name (optional)
  senderCompany: string,           // Issuing company
  paymentType: string,             // "cash" | "transfer"
  totalInvoiceAmount: number,      // Total invoice amount
  products: array[{                // Invoice line items
    productID_2: string,           // FK -> products
    packageID: string,             // FK -> packageTypes
    gramm: number,
    quantity: number,
    price: number,
    totalPrice: number
  }]
}
```

**Why Dual Storage?**
1. **Client-specific storage** (`clients/{id}/invoices`):
   - Easy to query invoices for one client
   - Client-centric views
2. **Centralized storage** (`all-invoices`):
   - Analytics across all clients
   - Payment type statistics
   - Product sales statistics
   - Sender company statistics

**Analytics Use Cases:**
```javascript
// Total revenue by payment type
all-invoices.reduce((acc, inv) => {
  acc[inv.paymentType] = (acc[inv.paymentType] || 0) + inv.totalInvoiceAmount;
  return acc;
}, {});

// Most sold products
all-invoices.flatMap(inv => inv.products)
  .reduce((acc, product) => {
    acc[product.productID_2] = (acc[product.productID_2] || 0) + product.quantity;
    return acc;
  }, {});
```

---

## Data Relationships

### Entity Relationship Diagram

```
┌─────────────┐
│    users    │
└─────┬───────┘
      │ uID (PK)
      │
      ├──────────────────┐
      │ creates          │ notifies
      │                  │
      ▼                  ▼
┌─────────────┐    ┌──────────────┐
│  invoices   │    │  low paper   │
│ (all-inv.)  │    │   alerts     │
└─────┬───────┘    └──────────────┘
      │ clientId (FK)
      │
      ▼
┌──────────────────────────────────────────┐
│              clients                     │
│  - Unique Design:                        │
│    • productID_2 → products (FK)         │
│    • packageID → packageTypes (FK)       │
│  - Standard Design:                      │
│    • productTypeID → productTypes (FK)   │
│    • catalogueItemID → catalogue (FK)    │
└───┬──────────────────────────────────────┘
    │
    ├─── paperRolls (subcollection)
    │    └─ Tracks individual rolls
    │
    ├─── logs (subcollection)
    │    └─ paperIn/paperOut history
    │
    ├─── invoices (subcollection)
    │    └─ Client-specific invoices
    │
    └─── branches (subcollection)
         └─ Multiple locations

┌──────────────┐
│  products    │◄─────┐
│  (base data) │      │
└──────────────┘      │
                      │
┌──────────────┐      │
│packageTypes  │◄─────┤
└──────┬───────┘      │
       │              │
       └─ possibleProducts   │
          (subcollection)    │
                             │
┌──────────────┐             │
│productTypes  │─────────────┘
│(standard     │
│ designs)     │
└──────┬───────┘
       │
       └─ logs (subcollection)
          └─ Standard paper usage

┌──────────────┐
│  catalogue   │◄── Referenced by productTypes
│ (with images)│    and standard design clients
└──────────────┘
```

---

## Primary Keys & Foreign Keys

### Primary Keys

| Collection | Primary Key Field | Type | Generation |
|-----------|------------------|------|------------|
| users | uID | String | Firebase Auth UID |
| clients | id | String | Firestore auto-generated |
| products | id | String | Firestore auto-generated |
| packageTypes | id | String | Firestore auto-generated |
| productTypes | id | String | Firestore auto-generated |
| catalogue | id | String | Firestore auto-generated |
| all-invoices | id | String | Firestore auto-generated |
| paperRolls | id | String | Firestore auto-generated (subcollection) |
| logs | id | String | Firestore auto-generated (subcollection) |
| invoices | id | String | Firestore auto-generated (subcollection) |

### Foreign Key Relationships

#### clients Collection

**Unique Design:**
```javascript
clients.productID_2 → products.id
clients.packageID → packageTypes.id
```

**Standard Design:**
```javascript
clients.productTypeID → productTypes.id
clients.catalogueItemID → catalogue.id
```

#### productTypes Collection
```javascript
productTypes.productID_2 → products.id
productTypes.packageID → packageTypes.id
productTypes.catalogueItemID → catalogue.id  // Optional
```

#### invoices / all-invoices Collections
```javascript
invoices.clientId → clients.id
invoices.userID → users.uID
invoices.products[].productID_2 → products.id
invoices.products[].packageID → packageTypes.id
```

#### logs Subcollections
```javascript
logs.userID → users.uID
// If under clients/{id}/logs, parent is clients
// If under productTypes/{id}/logs, parent is productTypes
```

---

## API Endpoints

### Authentication
**`GET /api/auth`**
- **Purpose:** Get ImageKit authentication token
- **Response:** `{ token, expire, signature }`
- **Usage:** Required before uploading images to ImageKit
- **Token Expiry:** 1 hour

### Telegram Notifications

**`POST /api/send-low-paper-alert`**
- **Purpose:** Send low paper alert to admin users via Telegram
- **Trigger:** When `client.paperRemaining <= client.notifyWhen`
- **Payload:**
  ```javascript
  {
    adminChatIds: string[],        // Array of admin Telegram chat IDs
    client: {
      name: string,
      restaurant: string,
      paperRemaining: number,
      notifyWhen: number
    }
  }
  ```
- **Action:** Sends formatted Telegram message to all admins

**`POST /api/send-low-paper-summary`**
- **Purpose:** Batch notification for multiple clients with low paper
- **Payload:**
  ```javascript
  {
    adminChatIds: string[],
    clients: [{
      name: string,
      paperRemaining: number,
      notifyWhen: number
    }]
  }
  ```
- **Action:** Sends summary list to admins

**`POST /api/send-location`**
- **Purpose:** Send restaurant location via Telegram
- **Payload:**
  ```javascript
  {
    chatId: string,
    userName: string,
    restaurantName: string,
    latitude: number,
    longitude: number
  }
  ```
- **Action:** Sends location map with coordinates

**`POST /api/telegram-webhook`**
- **Purpose:** Webhook endpoint for Telegram bot commands
- **Function:** `getPaperRolls(clientId)` - retrieves paper roll information
- **Usage:** Telegram bot integration for querying data

### Health Check
**`GET /api/health`**
- **Purpose:** API health check endpoint
- **Response:** Server status

---

## Data Flow Patterns

### 1. Client Creation Flow

```
User Creates Client
    │
    ├─ Selects Design Type
    │  ├─ "unique" (Custom Design)
    │  │  ├─ Select product → productID_2
    │  │  ├─ Select package → packageID
    │  │  └─ Enter gramm
    │  │
    │  └─ "standart" (Standard Design)
    │     ├─ Select from catalogue → catalogueItemID
    │     └─ Link to productTypeID
    │
    ├─ Creates clients/{id} document
    │  ├─ totalKg: 0
    │  ├─ paperRemaining: 0
    │  ├─ totalRolls: 0
    │  └─ notifyWhen: (user sets threshold)
    │
    └─ Initialize paperRolls subcollection (if unique)
```

### 2. Paper Addition Flow (Priyemka)

```
User Adds Paper to Client
    │
    ├─ Enter amount (kg)
    │
    ├─ IF designType === "unique"
    │  ├─ Create paperRolls/{id} document
    │  │  ├─ dateCreated: now
    │  │  └─ paperRemaining: amount
    │  │
    │  ├─ Update clients/{clientId}
    │  │  ├─ totalKg += amount
    │  │  ├─ paperRemaining += amount
    │  │  └─ totalRolls = count(paperRolls)
    │  │
    │  └─ Create log entry
    │     └─ clients/{clientId}/logs/{id}
    │        ├─ actionType: "paperIn"
    │        ├─ amount: amount
    │        ├─ userID: currentUser.uID
    │        └─ date: now
    │
    └─ IF designType === "standart"
       ├─ Update productTypes/{productTypeID}
       │  └─ Increment paper pool
       │
       └─ Create log entry
          └─ productTypes/{productTypeID}/logs/{id}
             ├─ actionType: "paperIn"
             ├─ amount: amount
             ├─ clientId: clientId
             └─ date: now
```

### 3. Paper Consumption Flow

```
User Records Paper Usage
    │
    ├─ Enter amount used (kg)
    │
    ├─ IF designType === "unique"
    │  ├─ Select paper roll(s) to deduct from
    │  │
    │  ├─ Update paperRolls/{rollId}
    │  │  └─ paperRemaining -= amount
    │  │
    │  ├─ Recalculate clients/{clientId}
    │  │  ├─ paperRemaining = SUM(paperRolls.paperRemaining)
    │  │  └─ totalRolls = count(paperRolls with paperRemaining > 0)
    │  │
    │  ├─ Create log entry
    │  │  └─ clients/{clientId}/logs/{id}
    │  │     ├─ actionType: "paperOut"
    │  │     ├─ amount: amount
    │  │     └─ date: now
    │  │
    │  └─ Check Alert Threshold
    │     └─ IF paperRemaining <= notifyWhen
    │        ├─ Query users where role === "admin"
    │        ├─ Collect admin chatIds
    │        └─ POST /api/send-low-paper-alert
    │
    └─ IF designType === "standart"
       ├─ Update productTypes/{productTypeID}
       │  └─ Decrement paper pool
       │
       ├─ Create log entry
       │  └─ productTypes/{productTypeID}/logs/{id}
       │     ├─ actionType: "paperOut"
       │     ├─ clientId: clientId
       │     └─ amount: amount
       │
       └─ Check productType threshold (if exists)
```

### 4. Invoice Generation Flow

```
User Creates Invoice
    │
    ├─ Select Client
    │  └─ Fetch clients/{clientId}
    │     ├─ Get orgName, restaurant
    │     └─ Check for branches subcollection
    │
    ├─ Select Branch (if available)
    │  └─ Fetch clients/{clientId}/branches/{branchId}
    │
    ├─ Select Products
    │  ├─ Fetch from products collection
    │  ├─ Fetch from packageTypes collection
    │  └─ User enters quantity, price per product
    │
    ├─ Calculate Total
    │  └─ totalInvoiceAmount = SUM(product.quantity * product.price)
    │
    ├─ Enter Invoice Details
    │  ├─ senderCompany (e.g., "White Ray")
    │  ├─ paymentType ("cash" | "transfer")
    │  └─ customRestaurantName (optional override)
    │
    ├─ Generate Invoice Number
    │  └─ invoiceNumber = auto-generated
    │
    ├─ Save to clients/{clientId}/invoices/{id}
    │  └─ Client-specific invoice history
    │
    └─ ALSO Save to all-invoices/{id}
       ├─ Include clientId as FK
       └─ Used for centralized analytics
```

### 5. Low Paper Alert Flow

```
Paper Consumption Triggers Check
    │
    ├─ Check: paperRemaining <= notifyWhen?
    │  │
    │  └─ YES → Continue
    │     NO → End
    │
    ├─ Verify actionType === "paperOut"
    │  └─ Only consumption triggers alerts, not additions
    │
    ├─ Query Admin Users
    │  └─ const admins = query(users, where('role', '==', 'admin'))
    │
    ├─ Filter admins with chatId
    │  └─ admins.filter(admin => admin.chatId)
    │
    ├─ Prepare Alert Payload
    │  └─ {
    │       adminChatIds: [chatId1, chatId2, ...],
    │       client: {
    │         name: client.name,
    │         restaurant: client.restaurant,
    │         paperRemaining: client.paperRemaining,
    │         notifyWhen: client.notifyWhen
    │       }
    │     }
    │
    └─ POST /api/send-low-paper-alert
       └─ Telegram Bot sends message to all admins
          └─ Message: "⚠️ Low paper alert for {restaurant}!
              Current: {paperRemaining} kg
              Threshold: {notifyWhen} kg"
```

### 6. Analytics Data Flow

```
Analytics Dashboard Loads
    │
    ├─ Client Statistics
    │  └─ Query all clients
    │     ├─ Total clients: count(clients)
    │     ├─ Total paper delivered: SUM(clients.totalKg)
    │     ├─ Paper remaining: SUM(clients.paperRemaining)
    │     └─ Active rolls: SUM(clients.totalRolls)
    │
    ├─ Usage Statistics
    │  └─ Query all client logs
    │     └─ Filter: actionType === "paperOut"
    │        ├─ Daily usage: SUM(amount) where date === today
    │        ├─ Weekly usage: SUM(amount) where date >= 7 days ago
    │        └─ Monthly usage: SUM(amount) where date >= 30 days ago
    │
    ├─ Invoice Statistics
    │  └─ Query all-invoices collection
    │     ├─ Total revenue: SUM(totalInvoiceAmount)
    │     ├─ By payment type:
    │     │  ├─ Cash: SUM where paymentType === "cash"
    │     │  └─ Transfer: SUM where paymentType === "transfer"
    │     ├─ By sender company:
    │     │  └─ GROUP BY senderCompany, SUM(totalInvoiceAmount)
    │     └─ By product:
    │        └─ FLATTEN products arrays, GROUP BY productID_2
    │
    ├─ Standard Design Statistics
    │  └─ Query productTypes
    │     └─ For each productType:
    │        └─ Query productTypes/{id}/logs
    │           └─ Calculate usage by standard design
    │
    └─ Package Type Statistics
       └─ Hard-coded package IDs:
          ├─ Stick: "sKHbhJ8Ik7QpVUCEgbpP"
          └─ Sachet: "fhLBOV7ai4N7MZDPkSCL"
          └─ Calculate distribution
```

---

## Query Patterns

### Common Firestore Queries

#### 1. Get User by Firebase Auth UID
```javascript
import { collection, query, where, getDocs } from 'firebase/firestore';

const getUserByAuthUID = async (firebaseUser) => {
  const q = query(
    collection(db, 'users'),
    where('uID', '==', firebaseUser.uid)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs[0]?.data();
};
```

#### 2. Get All Admin Users
```javascript
const getAdminUsers = async () => {
  const q = query(
    collection(db, 'users'),
    where('role', '==', 'admin')
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
```

#### 3. Get All Clients
```javascript
const getAllClients = async () => {
  const snapshot = await getDocs(collection(db, 'clients'));
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
```

#### 4. Get Client with Subcollections
```javascript
const getClientWithData = async (clientId) => {
  // Get client document
  const clientDoc = await getDoc(doc(db, 'clients', clientId));
  const clientData = { id: clientDoc.id, ...clientDoc.data() };

  // Get paper rolls
  const rollsSnapshot = await getDocs(
    collection(db, `clients/${clientId}/paperRolls`)
  );
  clientData.paperRolls = rollsSnapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));

  // Get logs
  const logsSnapshot = await getDocs(
    collection(db, `clients/${clientId}/logs`)
  );
  clientData.logs = logsSnapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));

  return clientData;
};
```

#### 5. Get Logs for Date Range
```javascript
const getLogsByDateRange = async (clientId, startDate, endDate) => {
  const logsRef = collection(db, `clients/${clientId}/logs`);
  const q = query(
    logsRef,
    where('date', '>=', startDate),
    where('date', '<=', endDate),
    orderBy('date', 'desc')
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
```

#### 6. Get All Invoices for Analytics
```javascript
const getAllInvoices = async () => {
  const snapshot = await getDocs(collection(db, 'all-invoices'));
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
```

#### 7. Get Invoices by Payment Type
```javascript
const getInvoicesByPaymentType = async (paymentType) => {
  const q = query(
    collection(db, 'all-invoices'),
    where('paymentType', '==', paymentType)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
```

#### 8. Get ProductType with Logs
```javascript
const getProductTypeWithLogs = async (productTypeId) => {
  const productTypeDoc = await getDoc(doc(db, 'productTypes', productTypeId));
  const productTypeData = { id: productTypeDoc.id, ...productTypeDoc.data() };

  const logsSnapshot = await getDocs(
    collection(db, `productTypes/${productTypeId}/logs`)
  );
  productTypeData.logs = logsSnapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));

  return productTypeData;
};
```

#### 9. Get Clients with Low Paper
```javascript
const getClientsWithLowPaper = async () => {
  const snapshot = await getDocs(collection(db, 'clients'));
  return snapshot.docs
    .map(doc => ({ id: doc.id, ...doc.data() }))
    .filter(client => client.paperRemaining <= client.notifyWhen);
};
```

#### 10. Get Catalogue Items by Package Type
```javascript
const getCatalogueByPackageType = async (packageType) => {
  const q = query(
    collection(db, 'catalogue'),
    where('packageType', '==', packageType.toLowerCase())  // "стик" or "саше"
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
```

### Aggregation Patterns

#### Calculate Total Paper Delivered
```javascript
const calculateTotalPaperDelivered = (clients) => {
  return clients.reduce((sum, client) => sum + (client.totalKg || 0), 0);
};
```

#### Calculate Total Revenue by Payment Type
```javascript
const calculateRevenueByPaymentType = (invoices) => {
  return invoices.reduce((acc, invoice) => {
    const type = invoice.paymentType;
    acc[type] = (acc[type] || 0) + invoice.totalInvoiceAmount;
    return acc;
  }, { cash: 0, transfer: 0 });
};
```

#### Calculate Most Sold Products
```javascript
const calculateMostSoldProducts = (invoices) => {
  const productStats = {};

  invoices.forEach(invoice => {
    invoice.products.forEach(product => {
      const key = product.productID_2;
      if (!productStats[key]) {
        productStats[key] = {
          productID: key,
          totalQuantity: 0,
          totalRevenue: 0
        };
      }
      productStats[key].totalQuantity += product.quantity;
      productStats[key].totalRevenue += product.totalPrice;
    });
  });

  return Object.values(productStats)
    .sort((a, b) => b.totalQuantity - a.totalQuantity);
};
```

---

## Key Business Logic

### 1. Paper Tracking Calculations

**Client Paper Balance:**
```javascript
// For unique design clients:
client.paperRemaining = SUM(paperRolls.paperRemaining)
client.totalRolls = COUNT(paperRolls documents)

// Paper consumption:
client.totalKg += amount  // Only increases (cumulative)
client.paperRemaining += amount (paperIn) or -= amount (paperOut)
```

**Standard Design Paper Balance:**
```javascript
// Shared pool across clients:
productType.paperRemaining = SUM(all paper additions) - SUM(all paper usage)
// Each client using this productType shares the same pool
```

### 2. Alert Threshold Logic

```javascript
// Trigger condition:
if (client.paperRemaining <= client.notifyWhen && actionType === "paperOut") {
  // Get admins with Telegram chatIds
  const admins = await getAdminUsers();
  const adminChatIds = admins
    .filter(admin => admin.chatId)
    .map(admin => admin.chatId);

  // Send alert
  if (adminChatIds.length > 0) {
    await sendLowPaperAlert({ adminChatIds, client });
  }
}
```

### 3. Role-Based Access Control

```javascript
// Check user role before showing sensitive data:
if (currentUser.role === "admin") {
  // Show: totalKg, orgName, analytics dashboard, user management
} else if (currentUser.role === "worker") {
  // Hide: totalKg, orgName
  // Show: basic client info, paper operations
}
```

### 4. Design Type Handling

```javascript
// When creating/editing client:
if (designType === "unique") {
  // Required fields:
  // - productID_2
  // - packageID
  // - gramm
  // - Initialize paperRolls subcollection
} else if (designType === "standart") {
  // Required fields:
  // - productTypeID (links to productTypes)
  // - catalogueItemID (links to catalogue)
  // - No paperRolls subcollection
  // - Use productTypes/{id}/logs for tracking
}
```

### 5. Invoice Number Generation

```javascript
// Auto-generate invoice numbers:
// Pattern: INV-YYYYMMDD-XXXXX
// Example: INV-20260112-00001

const generateInvoiceNumber = () => {
  const date = new Date();
  const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
  const randomNum = Math.floor(Math.random() * 100000).toString().padStart(5, '0');
  return `INV-${dateStr}-${randomNum}`;
};
```

### 6. Dual Invoice Storage

```javascript
// When creating invoice:
const invoiceData = {
  dateCreated: new Date(),
  invoiceNumber: generateInvoiceNumber(),
  userID: currentUser.uID,
  userName: currentUser.name,
  clientId: selectedClient.id,  // Only in all-invoices
  orgName: selectedClient.orgName,
  paymentType: selectedPaymentType,
  totalInvoiceAmount: calculateTotal(products),
  products: selectedProducts
};

// Save to both locations:
await addDoc(collection(db, `clients/${clientId}/invoices`), invoiceData);
await addDoc(collection(db, 'all-invoices'), invoiceData);
```

### 7. Package Type Hard-coded IDs

```javascript
// IMPORTANT: These IDs are used in analytics code
const PACKAGE_TYPE_IDS = {
  STICK: "sKHbhJ8Ik7QpVUCEgbpP",   // Стик
  SACHET: "fhLBOV7ai4N7MZDPkSCL"  // Саше
};

// Used for filtering and analytics:
const stickClients = clients.filter(c => c.packageID === PACKAGE_TYPE_IDS.STICK);
const sachetClients = clients.filter(c => c.packageID === PACKAGE_TYPE_IDS.SACHET);
```

---

## Image Storage (ImageKit)

### ImageKit Integration

**Service:** ImageKit CDN
**Base URL:** Configured in `/api/auth` endpoint

### Authentication Flow
```javascript
// 1. Get authentication token
const response = await fetch('/api/auth');
const { token, expire, signature } = await response.json();

// 2. Upload image with token
const formData = new FormData();
formData.append('file', imageFile);
formData.append('publicKey', IMAGEKIT_PUBLIC_KEY);
formData.append('signature', signature);
formData.append('expire', expire);
formData.append('token', token);

const uploadResponse = await fetch(IMAGEKIT_UPLOAD_URL, {
  method: 'POST',
  body: formData
});

const { url, fileId } = await uploadResponse.json();

// 3. Save to Firestore
await updateDoc(doc(db, 'clients', clientId), {
  imageURL: url
});
// OR for catalogue:
await updateDoc(doc(db, 'catalogue', catalogueId), {
  imageUrl: url,
  imagekitFileId: fileId
});
```

### Image URL Fields
- `clients.imageURL` - Client/restaurant photo
- `catalogue.imageUrl` - Catalog product image
- `catalogue.imagekitFileId` - ImageKit file ID for management

---

## Best Practices

### 1. Data Denormalization
- Cache frequently accessed data (e.g., `userName` in logs, `productName` in clients)
- Reduces read operations and improves performance
- Update cached data when source changes (consistency trade-off)

### 2. Subcollections vs. Arrays
- Use subcollections for: logs, invoices, paperRolls (unbounded growth)
- Use arrays for: invoice products (bounded, always loaded together)

### 3. Timestamp Handling
```javascript
import { serverTimestamp } from 'firebase/firestore';

// Always use server timestamp:
{
  createdAt: serverTimestamp(),
  date: serverTimestamp()
}
// Avoids client clock skew issues
```

### 4. Query Optimization
- Add indexes for compound queries (Firebase Console)
- Use pagination for large collections
- Cache frequently accessed data in application state

### 5. Security Rules
Implement Firestore Security Rules:
```javascript
// Example rule structure:
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only read their own document
    match /users/{userId} {
      allow read: if request.auth.uid == resource.data.uID;
      allow write: if request.auth.uid == resource.data.uID
                   || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin";
    }

    // Clients - read for authenticated, write for admin
    match /clients/{clientId} {
      allow read: if request.auth != null;
      allow write: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin";

      // Subcollections inherit parent permissions
      match /{subcollection}/{document=**} {
        allow read: if request.auth != null;
        allow write: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin";
      }
    }
  }
}
```

### 6. Error Handling
```javascript
try {
  await updateDoc(doc(db, 'clients', clientId), { paperRemaining });
} catch (error) {
  console.error('Failed to update client:', error);
  // Log to error tracking service (e.g., Sentry)
  // Show user-friendly message
}
```

---

## Troubleshooting

### Common Issues

#### 1. Missing Data in Queries
**Problem:** Query returns empty results
**Solution:**
- Check Firestore Security Rules
- Verify user authentication
- Check if indexes are created (Firebase Console)

#### 2. Telegram Notifications Not Sending
**Problem:** Low paper alerts not received
**Solution:**
- Verify admin users have `chatId` set
- Check Telegram bot token configuration
- Verify API endpoint is accessible
- Check client has `notifyWhen` threshold set

#### 3. Paper Balance Mismatch
**Problem:** `client.paperRemaining` doesn't match sum of `paperRolls`
**Solution:**
- Recalculate paper balance:
```javascript
const recalculateBalance = async (clientId) => {
  const rollsSnapshot = await getDocs(
    collection(db, `clients/${clientId}/paperRolls`)
  );
  const totalRemaining = rollsSnapshot.docs.reduce(
    (sum, doc) => sum + (doc.data().paperRemaining || 0),
    0
  );
  await updateDoc(doc(db, 'clients', clientId), {
    paperRemaining: totalRemaining,
    totalRolls: rollsSnapshot.size
  });
};
```

#### 4. Hard-coded Package IDs Not Working
**Problem:** Analytics showing incorrect package stats
**Solution:**
- Verify IDs match in database:
  - Stick: `sKHbhJ8Ik7QpVUCEgbpP`
  - Sachet: `fhLBOV7ai4N7MZDPkSCL`
- Check packageTypes collection documents

---

## Migration Notes

### Adding New Fields to Existing Collections

When adding new fields, use Firestore batch updates:

```javascript
import { writeBatch } from 'firebase/firestore';

const addFieldToAllClients = async () => {
  const batch = writeBatch(db);
  const snapshot = await getDocs(collection(db, 'clients'));

  snapshot.docs.forEach(doc => {
    batch.update(doc.ref, {
      newField: defaultValue
    });
  });

  await batch.commit();
  console.log(`Updated ${snapshot.size} clients`);
};
```

### Schema Changes

**Important:** Firestore is schemaless, but application code expects certain fields.

When changing schema:
1. Update all write operations first
2. Add migration script for existing documents
3. Update read operations
4. Test thoroughly before deployment

---

## Performance Tips

1. **Batch Reads:** Use `getAll()` for multiple documents
2. **Batch Writes:** Use `writeBatch()` for multiple updates (max 500 operations)
3. **Real-time Listeners:** Use `onSnapshot()` sparingly (costly)
4. **Indexes:** Create composite indexes for complex queries
5. **Pagination:** Use `startAfter()` and `limit()` for large lists
6. **Caching:** Cache reference data (products, packageTypes) in app state

---

## Version History

- **v1.0** (2026-01-12): Initial database guide created
  - Documented all 13 collections
  - Mapped relationships and foreign keys
  - Included query patterns and business logic

---

## Additional Resources

- **Firebase Firestore Docs:** https://firebase.google.com/docs/firestore
- **ImageKit Docs:** https://docs.imagekit.io/
- **Telegram Bot API:** https://core.telegram.org/bots/api

---

**End of Database Guide**

For questions or updates, contact the development team or update this document directly.